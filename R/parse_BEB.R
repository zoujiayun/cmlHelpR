#' Extract Bayes Empiracle Bayes information from codeml output
#'
#' Extracts all sites reported in the Bayes Empiracle Bayes section of the codeml output as a dataframe object
#' @param dir_path Directory path to codeml_parallel output directory
#' @param out_path Directory of where to write data frame object generated by parse_BEB()
#' @keywords Bayes, empiracle, Bayes, parse
#' @export
#' @examples
#' parse_BEB(dir_path = "path/to/parent_out", out_path = "path/to/output/name.tsv")
parse_BEB <- function(dir_path, out_path = NULL) {

  ## Importing data
  fl <- list.files(path = dir_path, pattern = "codeml.output", full.names = TRUE, recursive = TRUE)
  fl <- fl[stringr::str_detect(string = fl, pattern = "Model2Selection")]
  names(fl) <- sub(".+//(.*)/codeml.output", "\\1", fl)
  lst.fl <- purrr::map(fl, readr::read_lines)

  ## Iterating through each file extracting Bayes Empirical Bayes values
  lst.beb <- purrr::map(lst.fl, ~{

    int.start <- grep(pattern = "Bayes Empirical Bayes", x = .x)
    int.end <- grep(pattern = "The grid \\(see ternary graph for p0-p1\\)", x = .x)

    ## Conditional to get the right output
    if (isTRUE(.x[(int.start + 2)] == "") | rlang::is_empty(.x[(int.start + 2)])) {

      vec.sub <- c("NA NA NA") ## Entry for samples that don't have any information

    } else {

      vec.sub <- .x[(int.start+2):(int.end-3)]
      vec.sub <- trimws(x = vec.sub)

    }

  })

  lst.alignLength <- purrr::map(lst.fl, ~{
    int.noGapLen <- .x[grep(pattern = "After deleting gaps.", .x)]
    int.noGapLen <- as.numeric(sub(".*\\.\\s+(.*)\\s+sites", "\\1", int.noGapLen))
    tibble::tibble(no_gap_length = int.noGapLen)
  })
  lst.alignLength <- dplyr::bind_rows(lst.alignLength, .id = "condition")
  lst.alignLength <- dplyr::mutate(.data = lst.alignLength, condition = gsub("Model2Selection_", "", condition))

  ## Removing NULL elements
  lst.beb <- lst.beb[!sapply(lst.beb, is.null)]

  ## Converting to long-format dataframe
  df.beb <- purrr::map(lst.beb, ~{
    tmp <- tibble::enframe(x = .x, name = NULL)
    tmp <- tidyr::separate(data = tmp, col = value, into = c("aa_position", "aa", "val"), sep = " ")
  })
  df.beb <- dplyr::bind_rows(df.beb, .id = "condition")
  df.beb <- dplyr::mutate(df.beb, condition = stringr::str_remove(string = condition, pattern = "Model2Selection_"),
           pval = val)
  df.beb <- dplyr::mutate(df.beb, pval = 1 - as.numeric(stringr::str_remove_all(string = pval, pattern = "\\*")),
           signif = stringr::str_extract(string = val, pattern = "\\*+"),
           val = stringr::str_remove(val, "\\*+"),
           val = as.numeric(val),
           aa_position = as.integer(aa_position))

  df.beb <- dplyr::left_join(df.beb, lst.alignLength)
  df.beb <- tidyr::separate(df.beb, col = condition, into = c("gene", "tree"), sep = "/")

  ## Write outputs
  if (!is.null(out_path)) {

    readr::write_tsv(x = df.beb, path = out_path, col_names = TRUE)

  }

  return(df.beb)

}
